"""
# Models and Managers

The entities used by the project are represented by Django Model classes that enable the Bankifi database
to be autogenerated and provide a number of functional capabilities to support the class behaviour.

The methods contained in each model class are instance specific. The model managers provide functionality
that can go across instances.
"""
"""
**Available managers:**

1. ***InvoiceManager*** - Provides a number of cross model utility and aggregation methods for the Invoice Class

**Available model classes:**

1. ***Base*** - Base parent model for all the models to provide a set of standard timestamp methods
2. ***Contact*** - A representation of a supplier or customer contact
3. ***Invoice*** - A representation of an invoice
4. ***Account*** - A representation of a bank account
5. ***Transaction*** - A representation of a bank transaction
6. ***Loan*** - A representation of a loan
"""

# === Imports ===

# Import Python modules
from calendar import month_name
from datetime import datetime, timedelta, date
from random import choice, randrange
import itertools
import logging

# === Loggers ===

# Setup loggers
infolog = logging.getLogger('infologger')
errorlog = logging.getLogger('prodlogger')

# Import Django modules
from django.utils import timezone
from django.db import models
from django.db.models import Sum, Avg
from django.db.models import When, F, Q, ExpressionWrapper
from django.db.models import IntegerField, FloatField, fields
from django.db.models import CharField, Case, Value
from django.contrib.auth.models import User
from django.db.models.functions import ExtractMonth
from django.core.exceptions import ValidationError
from django.core.validators import MinLengthValidator
from django.core.exceptions import ValidationError
from django.utils.translation import ugettext_lazy as _
from django.conf import settings
from django.urls import reverse

# Import Bankifi utility methods
from aggregate.helpers import get_rates
from .utilities import due_date

# === Globals ===

# Hard coded Xero account links used for the Loan
BFS_CODE='39a174b7-4b74-45ed-9ef9-274b8cf72e0c'
BFS_NAME='BFS LOAN 3'

# === Model Managers ===

class InvoiceManager(models.Manager):
    """
    **InvoiceManager(models.Manager)**

    Provides a number of cross model utility and aggregation methods for the Invoice Class.

    **Methods:**

    1. ***aggregate*** - Returns the total receivables minus the total payables for all unpaid invoice.
    2. ***receivables*** - Returns the sum of all unpaid receivable invoices.
    3. ***payables*** - Returns the sum of all unpaid receivable invoices.
    4. ***rec_monthly*** - Returns a dictionary of total unpaid receivables by month.
    5. ***pay_monthly*** - Returns a dictionary of total unpaid payables by month.
    6. ***last_due*** - Return the last due invoice or None.
    7. ***days_to_pay*** - Return the number of days before the last invoice is due or 0
    """
    def aggregate(self, user):
        """
        **aggregate(self)**

        Returns the total receivables minus the total payables for all unpaid invoices.

        **Returns:**

        The total receivables minus the total payables for all unpaid invoices.
        """
        # Using the database to do all the work using aggregation
        aggregate = Invoice.objects.filter(customer=user).aggregate(
                    balance=Sum(
                            Case(
                                When(
                                    status=Invoice.UNPAID,
                                    invoice_type=Invoice.RECEIVABLE,
                                    then='amount'
                                ),
                                default=0,
                                output_field=FloatField(),
                            )
                        )-
                        Sum(
                            Case(
                                When(
                                    status=Invoice.UNPAID,
                                    invoice_type=Invoice.PAYABLE,
                                    then='amount'
                                ),
                                default=0,
                                output_field=FloatField(),
                            )
                        ),
                    )

        return aggregate['balance'] if aggregate['balance'] else 0.0


    def receivables(self,user):
        """
        **receivables(self)**

        Returns the sum of all unpaid receivable invoices.

        **Returns:**

        The sum of all unpaid receivable invoices or 0 if no invoices.
        """
        # Using the database to do all the work using aggregation
        aggregate = Invoice.objects.filter(customer=user).aggregate(
                    balance=Sum(
                            Case(
                                When(
                                    status=Invoice.UNPAID,
                                    invoice_type=Invoice.RECEIVABLE,
                                    then='amount'
                                ),
                                default=0,
                                output_field=FloatField(),
                            )
                        ),
                    )

        return aggregate['balance'] if aggregate['balance'] else 0.0


    def payables(self, user):
        """
        **payables(self)**

        Returns the sum of all unpaid payables invoices or 0 if no invoices.

        **Returns:**

        The sum of all unpaid payables invoices or 0 if no invoices.
        """
        # Using the database to do all the work using aggregation
        aggregate = Invoice.objects.filter(customer=user).aggregate(
                    balance=Sum(
                            Case(
                                When(
                                    status=Invoice.UNPAID,
                                    invoice_type=Invoice.PAYABLE,
                                    then='amount'
                                ),
                                default=0,
                                output_field=FloatField(),
                            )
                        ),
                    )

        return aggregate['balance'] if aggregate['balance'] else 0.0


    def rec_monthly(self, user):
        """
        **rec_monthly(self)**

        Returns a dictionary of total unpaid receivables by month.

        **Returns:**

        Dictionary with an ordered list of 'months' and an associated list of monthly invoice 'totals'.
        The dictionary lists will be empty if no invoices.
        """
        months = []
        totals = []
        reply = {}
        invoices = Invoice.objects.filter(customer=user, status=Invoice.UNPAID, invoice_type=Invoice.RECEIVABLE).\
                            annotate(period=ExtractMonth('due')).values('period').\
                            annotate(total=Sum('amount')).order_by('period')

        for i in invoices:
            months.append(month_name[i['period']])
            totals.append(i['total'])

        reply['months'] = months
        reply['totals'] = totals

        return reply


    def pay_monthly(self, user):
        """
        **pay_monthly(self)**

        Returns a dictionary of total unpaid payables by month.

        **Returns:**

        Dictionary with an ordered list of 'months' and an associated list of monthly invoice 'totals'.
        The dictionary lists will be empty if no invoices.
        """
        months = []
        totals = []
        reply = {}
        invoices = Invoice.objects.filter(customer=user, status=Invoice.UNPAID, invoice_type=Invoice.PAYABLE).\
                            annotate(period=ExtractMonth('due')).values('period').\
                            annotate(total=Sum('amount')).order_by('period')

        for i in invoices:
            months.append(month_name[i['period']])
            totals.append(i['total'])

        reply['months'] = months
        reply['totals'] = totals

        return reply



    def last_due(self, user):
        """
        **last_due(self)**

        Return the last due invoice.

        **Returns:**

        The last due invoice or None.
        """
        return Invoice.objects.filter(customer=user, status=Invoice.UNPAID, invoice_type=Invoice.RECEIVABLE).\
            order_by('-due').first()


    def days_to_pay(self, user):
        """
        **days_to_pay(self)**

        Return the number of days before the last invoice is due.

        **Returns:**

        The number of days before the last invoice is due or 0.
        """
        last = self.last_due(user)
        return (last.due - date.today()).days if last and last.due > date.today() else 0

# === Model Classes ===

class Base(models.Model):
    """
    **Base(models.Model)**

    Base parent model for all the models to provide a set of standard timestamp methods.

    **Public Attributes:**

    ***timestamp***: Editable timestamp.

    ***created***: Date and time model instance was created.

    ***updated***: Date and time model instance was updated.
    """
    timestamp = models.DateTimeField(blank=True, editable=False, db_index=True)
    created = models.DateTimeField(auto_now=False, auto_now_add=True, editable=False, verbose_name="Created")
    updated = models.DateTimeField(auto_now=True, auto_now_add=False, editable=False, verbose_name="Last Updated")


    def __init__(self, *args, **kwargs):
        super(Base, self).__init__(*args, **kwargs)

    class Meta:
        abstract = True

    # Override save method.
    def save(self,  *args, **kwargs):
        if not self.timestamp:
            self.timestamp = timezone.now()

        update_timestamp = kwargs.pop('update_timestamp', False)
        if update_timestamp:
            self.timestamp = timezone.now()

        super(Base, self).save(*args, **kwargs)




class Contact(Base):
    """
    **Contact(Base)**

    A representation of a supplier or customer contact.

    **Public Attributes:**

    ***name***: Contacts full name.

    ***first_name***: Contacts first name.

    ***last_name***: Contacts last name.

    ***contact_id***: Stores the Xero contact_id.

    **Methods:**

    ***is_supplier***: Determines if a contact is a supplier.

    ***is_customer***: Determines if a contact is a customer

    ***customer_settle***: Calculates the average duration a customer takes to settle invoices.

    ***supplier_settle***: Calculates the average duration it takes to settle supplier invoices.
    """
    name = models.CharField(max_length=60, verbose_name="Name", blank=True)
    first_name = models.CharField(max_length=30, verbose_name="First Name")
    last_name = models.CharField(max_length=30, verbose_name="Last Name")
    contact_id = models.CharField(max_length=100, verbose_name="Xero Contact ID", blank=True)

    class meta:
        ordering = ['name']

    # Override save method to set the full name using first and last name.
    def save(self,  *args, **kwargs):
        if self.first_name and self.last_name:
            self.name = self.first_name + ' ' + self.last_name

        super(Contact, self).save(*args, **kwargs)


    @property
    def is_supplier(self):
        """
        **is_supplier(self)**

        Determines if a contact is a supplier by checking if they have payable invoices registered against them.

        **Returns:**

        True if contact is a supplier otherwise False.
        """
        return Invoice.objects.filter(contact=self, invoice_type=Invoice.PAYABLE).exists()


    @property
    def is_customer(self):
        """
        **is_customer(self)**

        Determines if a contact is a customer by checking if they have receivable invoices registered against them.

        **Returns:**

        True if contact is a supplier otherwise False.
        """
        return Invoice.objects.filter(contact=self, invoice_type=Invoice.RECEIVABLE).exists()


    @property
    def customer_settle(self):
        """
        **customer_settle(self)**

        Calculates the average duration a customer takes to settle receivable invoices.

        **Returns:**

        Average number of days to settle or 0.
        """
        if self.is_customer:
            duration = ExpressionWrapper(F('actual')-F('raised'), output_field=fields.DurationField())
            settle = Invoice.objects.filter(contact__id=self.id,
                    invoice_type=Invoice.RECEIVABLE,
                    status=Invoice.PAID).annotate(duration=duration).\
                    aggregate(settle=Avg('duration')).get('settle', 0)
            return settle.days if settle else 0
        else:
            return 0


    @property
    def supplier_settle(self):
        """
        **supplier_settle(self)**

        Calculates the average duration taken to settle a supplier payable invoice.

        **Returns:**

        Average number of days to settle or 0.
        """
        if self.is_supplier:
            duration = ExpressionWrapper(F('actual')-F('raised'), output_field=fields.DurationField())
            settle = Invoice.objects.filter(contact__id=self.id,
                    invoice_type=Invoice.PAYABLE,
                    status=Invoice.PAID).annotate(duration=duration).\
                    aggregate(settle=Avg('duration')).get('settle', 0)
            return settle.days if settle else 0

        else:
            return 0


    def __str__(self):
        return "{0}".format(self.name)


    def get_absolute_url(self):
        return reverse("cashflow:contactdetail", kwargs={"pk":self.pk})



class Invoice(Base):
    """
    **Invoice(Base)**

    A representation of an Invoice.

    An invoice can be a receivable or a payable. It can be in a paid or unpaid state.
    A receivable is an invoiced amount owed by a customer.
    A payable is an invoiced amount owed to a supplier.

    **Public Attributes:**

    ***invoice_type***: type of invoice; PAYABLE or RECEIVABLE.

    ***number***: invoice number for the Invoice (this should be unique if being used with Xero).

    ***contact***: foreign key to the contact (customer or supplier) associated with the invoice.

    ***raised***: date the invoice was raised(i.e created).

    ***bank_account***: A foreign key to the bank account were the invoice will be paid to/paid from.

    ***due***: date the invoice is due for payment.

    ***expected***: date the invoice is expected to be paid based on historic averages.

    ***planned***: date the invoice is planned to be paid.

    ***actual***: date the invoice was paid on.

    ***amount***: invoice amount.

    ***status***: status of the invoice; PAID or UNPAID.

    ***invoice_obj***: InvoiceManager.

    **Methods:**

    ***pay***: Pay an invoice.
    ***days_to_settle***: Number of days it took to settle the invoice.
    """
    PAYABLE = 'PAYABLE'
    RECEIVABLE = 'RECEIVABLE'
    INVOICE_TYPE = (
        (PAYABLE, 'Payable'),
        (RECEIVABLE, 'Receivable'),
    )

    PAID = 'PAID'
    UNPAID = 'UNPAID'
    INVOICE_STATUS = (
        (PAID, 'Paid'),
        (UNPAID, 'Unpaid'),
    )
    customer = models.ForeignKey(settings.AUTH_USER_MODEL, default=1, on_delete=models.CASCADE,
        verbose_name="Customer")
    invoice_type = models.CharField(choices=INVOICE_TYPE, max_length=15, help_text="Invoice type",
        verbose_name="Type")
    number = models.CharField(max_length=25, help_text="Invoice number will be autogenerated.",
        verbose_name="Invoice Number", blank=True)
    contact = models.ForeignKey('Contact', help_text="Customer/Supplier contact",
        verbose_name="Contact", on_delete=models.CASCADE)
    raised = models.DateField(help_text="Date invoice was raised", verbose_name="Date Raised",
        default=date.today)
    bank_account = models.ForeignKey('Account', help_text="Bank Account to use for Payable Receivables",
        verbose_name="Bank Account", on_delete=models.CASCADE)
    due = models.DateField(help_text="Date invoice is due", verbose_name="Date Due", default=due_date)
    expected = models.DateField(help_text="Date invoice is expected to be paid", verbose_name="Date Expected",
        null=True, blank=True)
    planned = models.DateField(help_text="Date invoice is planned to be paid", verbose_name="Date Planned",
        null=True, blank=True)
    actual = models.DateField(help_text="Date invoice was paid", verbose_name="Date Paid", null=True,
        blank=True)
    amount = models.FloatField(default=0.0, help_text="Invoice total amount", verbose_name="Amount")
    status = models.CharField(choices=INVOICE_STATUS, max_length=10, help_text="Invoice payment status",
        verbose_name="Status", default=UNPAID)
    objects = models.Manager()
    invoice_obj = InvoiceManager()


    class meta:
        ordering = ['created']

    # Override save method to set the planned and expected dates based on historic averages.
    def save(self,  *args, **kwargs):
        # Need to save here to get the id
        super(Invoice, self).save(*args, **kwargs)
        # Save to set primary key id
        if not self.number:
            self.number = "BI-INV-{0}-{1}-{2}".format(randrange(10000), randrange(10000), randrange(100))


        if self.raised and self.status == self.UNPAID and self.invoice_type == self.PAYABLE:
            if  self.contact.supplier_settle and \
                    (self.raised + timedelta(days=self.contact.supplier_settle)) > date.today():
                self.planned = self.raised + timedelta(days=self.contact.supplier_settle)
                self.expected = self.due
            else:
                self.planned = self.due
                self.expected = self.planned

        if self.raised and self.status == self.UNPAID and self.invoice_type == self.RECEIVABLE:
            if self.invoice_type == self.RECEIVABLE and self.contact.customer_settle and \
                    (self.raised + timedelta(days=self.contact.customer_settle)) > date.today():
                self.expected = self.raised + timedelta(days=self.contact.customer_settle)
            else:
                self.expected = self.due

        super(Invoice, self).save(*args, **kwargs)


    def __str__(self):
        return "{0}".format(self.number)


    def get_absolute_url(self):
        return reverse("cashflow:invoicedetail", kwargs={"pk":self.pk})


    def pay(self, user, account, xero=None):
        """
        **pay(self, account, xero=None)**

        Pays an invoice and update Bankifi and Xero.

        Future Work: decouple Xero calls from class to allow multiple 3rd party providers

        **Parameters:**

        ***account***: the account the funds are being deposited to/withdrawn from.

        ***xero***: xero connection handler.

        **Returns**:

        Nothing

        **Exceptions:**

        ***ValidationError***: refused
        """
        # Retrieve Bankifi account object
        account = Account.objects.filter(customer=user, account_id=account).first()
        # Pay supplier invoice
        if account and self.invoice_type == self.PAYABLE and self.status != self.PAID:
            if account.withdraw(user, self.amount, "Payment to {0} for invoice {1}".format(self.contact, self.number),
                    xero):
                xero.payments.put({
                    'Invoice': {'InvoiceNumber': self.number},
                    'Account': {'AccountID': account.account_id},
                    'Amount': self.amount,
                    'Date': datetime.now().date()
                    })

                self.bank_account.deposit(user, self.amount, "Payment from {0} for invoice {1}".format(self.contact,
                    self.number))
                # Mark as paid
                self.status = self.PAID
                self.actual = datetime.now().date()
                self.save()
            else:
                raise ValidationError(_("The bank has refused the transaction due to lack of funds available."),
                    code='refused')
        # Receive customer invoice payment
        elif account and self.invoice_type == self.RECEIVABLE and self.status != self.PAID:
            xero.payments.put({
                'Invoice': {'InvoiceNumber': self.number},
                'Account': {'AccountID': account.account_id},
                'Amount': self.amount,
                'Date': datetime.now().date()
                })

            self.bank_account.deposit(user, self.amount,
                "Payment from {0} for invoice {1}".format(self.contact, self.number))
            self.status = self.PAID
            self.actual = datetime.now().date()
            self.save()


    @property
    def days_to_settle(self):
        """
        **days_to_settle(self)**

        Returns the number of days it has taken to settle the invoice.

        ***Returns:***

        Number of days it has taken to settle the invoice or 0.
        """
        return (self.actual - self.raised).days if self.actual and self.raised else 0



class Account(Base):
    """
    **Account(Base)**

    A representation of a Bank Account.

    Utilises a subset of banks.
    A bank account can have an optional sweep bank account associated with it.
    The sweep account will be used to try and return the account to a minimum balance level if
    there is an attempt to withdraw funds that would otherwise cause a transaction to be declined or
    cause the account to become overdrawn.

    Future Work: decouple Xero calls from class to allow multiple 3rd party providers

    **Public Attributes:**

    ***bank***: bank name limited by a set of choices.

    ***name***: account name.

    ***sortcode***: bank sortcode.

    ***account_number***: bank account number.

    ***sweep_min_balance***: minimum balance before sweep rule takes effect.

    ***sweep_account***: foreign key to optional sweep account.

    ***account_id***: Id of Xero equivalent account.

    **Methods:**

    ***sweep***: sweep funds from linked sweep account to restore balance to minimum level.

    ***deposit***: deposit funds.

    ***withdraw***: withdraw funds.

    ***transaction_check***: check if sufficient funds available prior to withdrawal.

    ***balance***: return the current bank account balance.
    """
    # Subset of available banks. Add to this list to add more or setup in database in future.
    BARCLAYS = 'BARCLAYS'
    HSBC = 'HSBC'
    NORDEA = 'NORDEA'
    NATIONWIDE = 'NATIONWIDE'
    RBS = 'RBS'
    LLOYDS = 'LLOYDS'
    SANTANDER = 'SANTANDER'

    BANK = (
        (BARCLAYS, 'BARCLAYS'),
        (HSBC, 'HSBC'),
        (NORDEA, 'NORDEA'),
        (NATIONWIDE, 'NATIONWIDE'),
        (RBS, 'RBS'),
        (LLOYDS, 'LLOYDS'),
        (SANTANDER, 'SANTANDER'),
    )

    EURO = 'EURO'
    USD = 'USD'
    GBP = 'GBP'

    CURRENCY = (
        (EURO, 'EURO'),
        (USD, 'USD'),
        (GBP, 'GBP'),
    )
    customer = models.ForeignKey(settings.AUTH_USER_MODEL, default=1, on_delete=models.CASCADE,
        verbose_name="Customer")
    bank = models.CharField(choices=BANK, max_length=10,
        verbose_name="Bank", default=NATIONWIDE)
    name = models.CharField(max_length=40,
        verbose_name="Account Name")
    sortcode = models.CharField(max_length=11, validators=[MinLengthValidator(6)],
        verbose_name="Sort Code/Swift BIC", blank=True)
    account_number = models.CharField(max_length=20,
        validators=[MinLengthValidator(8)],
        verbose_name="Account Number/IBAN")
    currency = models.CharField(choices=CURRENCY, max_length=10, help_text="Currency",
        verbose_name="Currency", default=GBP)
    sweep_min_balance = models.FloatField(default=0,
        verbose_name="Sweep Balance Limit")
    sweep_account = models.ForeignKey('Account', null=True, blank=True,
         verbose_name="Sweep Account")
    account_id = models.CharField(max_length=100, verbose_name="Xero Account ID", blank=True)


    class meta:
        ordering = ['bank']

    # Override save method to setup made up bank sortcodes and conduct account sweep if necessary.
    def save(self,  *args, **kwargs):
        sort_codes = {
            'BARCLAYS': '111111',
            'HSBC': '222222',
            'NORDEA': '333333',
            'NATIONWIDE': '444444',
            'RBS': '555555',
            'LLOYDS': '666666',
            'SANTANDER': '777777',
        }
        super(Account, self).save(*args, **kwargs)

        if not self.name:
            self.name = "Bank Account {0}".format(self.id)
            # Save to set primary key id
            super(Account, self).save(*args, **kwargs)

        if not self.sortcode:
            self.sortcode = sort_codes.get(self.bank, '000000')
            super(Account, self).save(*args, **kwargs)

        if self.balance(self.customer) < self.sweep_min_balance:
            self.sweep()


    def sweep(self, user, amount=0.0, xero=None):
        """
        **sweep(self, amount=0.0, xero=None)**

        Sweep funds from linked bank account to restore balance to minimum level.

        Sweeps only the funds required to make withdrawal amount and set account to minimum balance.
        The sweep is applied to both Bankifi and Xero.

        Future Work: decouple Xero calls from class to allow multiple 3rd party providers

        **Parameters:**

        ***amount***: amount to be withdrawn from account.

        ***xero***: xero connection object.

        **Returns:**

        Nothing
        """
        amount_required = (amount - self.balance(user)) + self.sweep_min_balance
        if self.sweep_account:
            if xero:
                xero.banktransfers.put({
                        'ToBankAccount': {'AccountID': self.account_id},
                        'FromBankAccount': {'AccountID': self.sweep_account.account_id},
                        'Amount': amount_required,
                        })
            self.sweep_account.withdraw(user, amount_required, "Sweep Payment to {0} {1}".format(self.sortcode, self.account_number),
                xero)
            self.deposit(user, amount_required, "Sweep Payment from {0} {1}".format(self.sortcode, self.account_number))



    def deposit(self, user, amount=0.0, description="Deposit", xero=None, contact_id=None, account_id=''):
        """
        **deposit(self, amount=0.0, description="Deposit", xero=None, contact_id=None, account_id='')**

        Deposit funds into bank account. Updates Bankifi and Xero account.

        Future Work: decouple Xero calls from class to allow multiple 3rd party providers.

        **Parameters:**

        ***amount***: deposit amount.

        ***description***: deposit description.

        ***xero***: xero connection object.

        ***contact_id***: Xero contact id.

        ***account_id***: Xero account id.

        **Returns:**

        True if successful. False if unsuccessful.
        """
        # Only deposit positive amounts > 0
        if amount > 0:
            if xero and contact_id:
                transaction = {
                    'Type': 'RECEIVE',
                    'Contact': {'ContactID': contact_id},
                    'Date': datetime.now(),
                    'LineAmountTypes': 'Inclusive',
                    'LineItems': [{'Description': description,
                        'Quantity': '1.0', 'UnitAmount': amount, 'ItemCode': '1'}],
                    'BankAccount': {'AccountID': account_id},
                    'Status': 'AUTHORISED'
                }

                # Create Xero transaction to deposit funds
                xero.banktransactions.put(transaction)

            # Create bankif transaction to deposit funds
            t = Transaction(customer=user, account=self, transaction_type=Transaction.CREDIT, amount=amount,
                    description=description)

            # Save Bankifi Transaction
            if t is not None:
                t.save()
            return True
        else:
            return False


    def withdraw(self, user, amount=0.0, description="Withdrawal", xero=None, contact_id=None, account_id=''):
        """
        **withdraw(self, amount=0.0, description="Withdrawal", xero=None, contact_id=None, account_id='')**

        Withdraw funds from bank account. Updates Bankifi and Xero account.

        Future Work: decouple Xero calls from class to allow multiple 3rd party providers

        **Parameters:**

        ***amount***: withdrawal amount.

        ***description***: withdrawal description.

        ***xero***: xero connection object.

        ***contact_id***: Xero contact id.

        ***account_id***: Xero account id.

        **Returns:**

        True is successful. False if unsuccessful.
        """
        # Check the withdrawal amount is > 0 and that the account has sufficient funds for withdrawal
        if amount > 0 and self.transaction_check(user, amount, xero):
            if xero and contact_id:
                transaction = {
                    'Type': 'SPEND',
                    'Contact': {'ContactID': contact_id},
                    'Date': datetime.now(),
                    'LineAmountTypes': 'Inclusive',
                    'LineItems': [{'Description': description,
                        'Quantity': '1.0', 'UnitAmount': amount, 'AccountCode': '900'}],
                    'BankAccount': {'AccountID': self.account_id},
                    'Status': 'AUTHORISED'
                }

                # Create Xero transaction to withdraw funds
                xero.banktransactions.put(transaction)

            # Create bankif transaction to withdraw funds
            t = Transaction(customer=user, account=self, transaction_type=Transaction.DEBIT, amount=amount,
                    description=description)

            # Save Bankifi Transaction
            if t is not None:
                t.save()
            return True
        else:
            return False



    def transaction_check(self, user, amount, xero=None):
        """
        **transaction_check(self, amount, xero=None)**

        Checks account has sufficient funds prior to making withdrawal.

        Will include the funds available within a sweep account as part of the check if necessary.


        **Parameters:**

        ***amount***: withdrawal amount

        ***xero***: xero connection object

        **Returns:**

        True if successful. False if unsuccessful.
        """
        if self.balance(user) >= amount:
            return True
        elif self.sweep_account and self.sweep_account.transaction_check(user, amount-self.balance(user)):
            self.sweep(user, amount, xero)
            return True
        else:
            return False


    # @property
    # def balance(self):
    #     """
    #     **balance(self)**

    #     Returns the balance of the bank account.

    #     Aggregates the transactions against the account to find the current balance.

    #     **Returns:**

    #     The account balance or 0 if no transactions exist.
    #     """
    #     if Transaction.objects.filter(account_id=self.id).exists():
    #         return Transaction.objects.filter(account_id=self.id).aggregate(Sum('amount')).get('amount__sum',0.0)
    #     else:
    #         return 0.0

    def balance(self, user):
        """
        **balance(self, user)**

        Returns the balance of the bank account.

        Aggregates the transactions against the account to find the current balance.

        **Returns:**

        The account balance or 0 if no transactions exist.
        """
        # Seems like this doesn't work as expected, total balance returns 0.0 when there should be something.
        # See issue: https://github.com/thestartupfactory/bankifi/issues/6
        if Transaction.objects.filter(customer=user, account_id=self.id).exists():
            infolog.info("Let me show you the current user: {0}\nAnd the account_id: {1}".format(user, self.id))
            result = Transaction.objects.filter(customer=user, account_id=self.id).aggregate(Sum('amount')).get('amount__sum',0.0)
            infolog.info("Found account balance - returning... {0}".format(result))
            return result
        else:
            errorlog.error("Unable to find balance for user - returning nil.")
            return 0.0


    def __str__(self):
        return "{0} {1} {2}".format(self.bank.title(), self.name, self.account_number)


    def get_absolute_url(self):
        return reverse("cashflow:accountdetail", kwargs={"pk":self.pk})


class TransactionManager(models.Manager):
    """
    **TransactionManager(models.Manager)**

    Provides a number of aggregation methods for the Transaction Class.

    **Methods:**

    1. ***networth*** - Returns the networth of the individual.
    2. ***debits*** - Returns the total value of debits across accounts.
    3. ***credit*** - Returns the total valie of credits across accounts.

    """
    def networth(self, customer, base):
        """
        **networth(self)**

        Returns the total networth of the account balances.

        **Returns:**

        The networth.

        TODO: At the moment we just total the amount and do no currency conversion. This needs to be done.
        """
        months, totals = self.trans_stats({'customer': customer, 'amount__isnull': False}, base)

        return {'months': months, 'networths': totals}
        # return {}


    def networth_total(self, customer):
        """
        **debit_total(self)**

        Returns the total value of all debits across accounts.

        **Returns:**

        The total networth across accounts.

        TODO: At the moment we just total the amount and do no currency conversion. This needs to be done.
        """
        # Using the database to do all the work using aggregation
        total = Transaction.objects.filter(customer=customer, amount__isnull=False).\
                                aggregate(networth=Sum('amount')).get('networth', 0.0)

        return total



    def credits(self, customer, base):
        """
        **credits(self)**

        Returns the total value of all credits across accounts.

        **Returns:**

        The total credits.

        TODO: At the moment we just total the amount and do no currency conversion. This needs to be done.
        """

        months, totals = self.trans_stats({'customer': customer, 'amount__isnull': False,
                        'transaction_type': Transaction.CREDIT}, base)

        return {'months': months, 'credits': totals}


    def credit_total(self, customer):
        """
        **credit_total(self)**

        Returns the total value of all credits across accounts.

        **Returns:**

        The total credits.

        TODO: At the moment we just total the amount and do no currency conversion. This needs to be done.
        """
        # Using the database to do all the work using aggregation
        total = Transaction.objects.filter(customer=customer, amount__isnull=False, transaction_type=Transaction.CREDIT).\
                                aggregate(credits=Sum('amount')).get('credits', 0.0)

        return total


    def debits(self, customer, base):
        """
        **debits(self)**

        Returns the total value of all debits across accounts.

        **Returns:**

        The total debits.

        TODO: At the moment we just total the amount and do no currency conversion. This needs to be done.
        """

        months, totals = self.trans_stats({'customer': customer, 'amount__isnull': False,
                        'transaction_type': Transaction.DEBIT}, base)

        return {'months': months, 'debits': totals}



    def debit_total(self, customer):
        """
        **debit_total(self)**

        Returns the total value of all debits across accounts.

        **Returns:**

        The total debits.

        TODO: At the moment we just total the amount and do no currency conversion. This needs to be done.
        """
        # Using the database to do all the work using aggregation
        total = Transaction.objects.filter(customer=customer, amount__isnull=False, transaction_type=Transaction.DEBIT).\
                                aggregate(debits=Sum('amount')).get('debits', 0.0)

        return total


    def trans_stats(self, rules, base):
        rates = get_rates(base)

        transactions = Transaction.objects.filter(**rules).\
                annotate(period=ExtractMonth('transdate')).values('period').\
                annotate(gbp=Case(
                    When(currency=Transaction.GBP, then=Sum(F('amount')/rates['GBP'])),
                    default=0, output_field=FloatField(),
                )).\
                annotate(eur=Case(
                    When(currency=Transaction.EURO, then=Sum(F('amount')/rates['EUR'])),
                    default=0, output_field=FloatField(),
                )).\
                annotate(usd=Case(
                    When(currency=Transaction.USD, then=Sum(F('amount')/rates['USD'])),
                    default=0, output_field=FloatField(),
                )).\
                annotate(total=F('gbp') + F('eur') + F('usd')).\
                order_by('period')


        months = []
        totals = []
        for key, group in itertools.groupby(transactions, lambda item: item["period"]):
            months.append(month_name[key])
            total = sum([item["total"] for item in group])
            totals.append(round(total, 2))

        return months, totals


class Transaction(Base):
    """
    **Transaction(Base)**

    A representation of a bank transaction.

    A transaction can be a debit or a credit transaction.

    Future Work: decouple Xero calls from class to allow multiple 3rd party providers.

    **Public Attributes:**

    ***account***: foreign key to bank account.

    ***transaction_type***: type of transaction; DEBIT or CREDIT.

    ***amount***: transaction amount.

    ***contact***: foreign key to contact for transaction.

    ***transdate***: date and time of transaction.

    ***transaction_id***: Id of Xero equivalent transaction.
    """
    DEBIT = 'DEBIT'
    CREDIT = 'CREDIT'
    TRANSACTION_TYPE = (
        (DEBIT, 'Debit'),
        (CREDIT, 'Credit'),
    )

    EURO = 'EURO'
    USD = 'USD'
    GBP = 'GBP'

    CURRENCY = (
        (EURO, 'EURO'),
        (USD, 'USD'),
        (GBP, 'GBP'),
    )


    customer = models.ForeignKey(settings.AUTH_USER_MODEL, default=1, on_delete=models.CASCADE,
        verbose_name="Customer", help_text="Customer")
    account = models.ForeignKey('Account', help_text="Bank Account", verbose_name="Account", on_delete=models.CASCADE)
    transaction_type = models.CharField(choices=TRANSACTION_TYPE, max_length=10, help_text="Transaction type",
        verbose_name="Type")
    amount = models.FloatField(default=0.0, help_text="Transaction Amount", verbose_name="Amount")
    currency = models.CharField(choices=CURRENCY, max_length=10, help_text="Currency",
        verbose_name="Currency", default=GBP)
    description = models.CharField(max_length=250, help_text="Transaction description", verbose_name="Description",
        blank=True)
    contact = models.ForeignKey('contact', verbose_name="Xero Contact", null=True)
    transdate = models.DateTimeField(blank=True, verbose_name="Date and Time", help_text="Transaction date and time",
        auto_now=True)
    transaction_id = models.CharField(max_length=100, verbose_name="Xero Account ID", blank=True)

    objects = TransactionManager()

    class meta:
        ordering = ['-created']


    # Override save method to ensure correct amounts are applied to the account.
    def save(self,  *args, **kwargs):
        if not self.description:
            self.description = "{0} Payment".format(self.transaction_type)

        # Ensure positive amounts from credits and negative amount for debits
        if self.amount < 0.0 and self.transaction_type == self.CREDIT:
            self.amount = self.amount * -1.0

        if self.amount > 0.0 and self.transaction_type == self.DEBIT:
            self.amount = self.amount * -1.0

        super(Transaction, self).save(*args, **kwargs)


    def __str__(self):
        return "{0}".format(self.id)


    def get_absolute_url(self):
        return reverse("cashflow:transactiondetail", kwargs={"pk":self.pk})



class Loan(models.Model):
    """
    **Loan(models.Model)**

    A representation of a loan.

    A loan can be in a PAID and OUTSTANDING state. Only one loan is currently allowed in Bankifi.

    Future Work: support multiple loans and decouple Xero calls from class to allow multiple 3rd party providers.

    **Public Attributes:**

    ***balance***: loan balance.

    ***account***: linked loan bank account.

    ***status***: current status of the loan; PAID or OUTSTANDING.

    **Methods:**

    ***transfer_funds***: transfers loan funds into bank account.

    ***pay_loan***: pay an amount off of the loan.
    """
    PAID = 'PAID'
    OUTSTANDING = 'OUTSTANDING'
    LOAN_STATUS = (
        (PAID, 'Paid'),
        (OUTSTANDING, 'Outstanding'),
    )

    customer = models.ForeignKey(settings.AUTH_USER_MODEL, default=1, on_delete=models.CASCADE,
        verbose_name="Customer", help_text="Customer")
    balance = models.FloatField(default=0, verbose_name="Loan Balance")
    account = models.ForeignKey('account')
    status = models.CharField(choices=LOAN_STATUS, max_length=15, default=OUTSTANDING, verbose_name="Status",
        help_text="Status of the loan")


    def transfer_funds(self, user, amount, xero, contact_id, account_id):
        """
        **transfer_funds(self, amount, xero, contact_id, account_id)**

        Transfer funds from loan account to Xero and Bankifi accounts.

        Uses a loan account pre-setup on Bankifi and Xero.

        Future Work: Make the loan accounts more flexible and not tied to hard coded values.

        **Parameters:**

        ***amount***: loan amount to transfer.

        ***xero***: xero connection object.

        ***account_id***: account to transfer funds too.

        **Returns:**

        Nothing
        """
        xero.banktransfers.put({
                                'FromBankAccount': {'AccountID': BFS_CODE},
                                'ToBankAccount': {'AccountID': account_id},
                                'Amount': amount,
                            })
        self.account.deposit(user, amount, "Loan Deposit for loan Id: {0}".format(self.id))
        self.save()


    def pay_loan(self, user, amount=0, xero=None, contact_id=None, account_id=''):
        """
        **pay_loan(self, amount=0, xero=None, contact_id=None, account_id='')**

        Pay an amount of the loan.

        Uses a loan account pre-setup on Bankifi and Xero.

        Future Work: Make the loan accounts more flexible and not tied to hard coded values.

        **Parameters:**

        ***amount***: amount to pay off the loan.

        ***xero***: xero connection object.

        ***contact_id***: xero contact id.

        ***account_id***: account to transfer funds from.

        **Returns:**

        Nothing
        """
        # If we are using a negative amount convert to positive
        if amount < 0:
            amount *= -1
        # Raise an error if the loan has already been settled
        if self.status == self.PAID:
            raise ValidationError(_("Loan has already been fully paid."), code="loanalreadypaid")
        # Check funds are available to pay off the loan
        elif self.account.balance(user) >= amount:
            self.account.withdraw(user, amount, "Loan Payment for loan Id: {0}".format(self.id), xero)
            xero.banktransfers.put({
                                'FromBankAccount': {'AccountID': account_id},
                                'ToBankAccount': {'AccountID': BFS_CODE},
                                'Amount': amount,
                            })
            self.balance += amount
            # If the balance is now 0 or less set the loan to PAID state
            if self.balance <= 0.0:
                self.status = self.PAID
            self.save()


    def __str__(self):
        # return "{0}".format(self.balance(user))
        return "{0}".format(self.balance)

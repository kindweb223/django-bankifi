""" 
# Models and Managers

The entities used by the project are represented by Django Model classes that enable the Bankifi database
to be autogenerated and provide a number of functional capabilities to support the class behaviour.

The methods contained in each model class are instance specific. The model managers provide functionality
that can go across instances. 
"""
"""
**Available managers:**

1. ***InvoiceManager*** - Provides a number of cross model utility and aggregation methods for the Invoice Class

**Available model classes:**

1. ***Base*** - Base parent model for all the models to provide a set of standard timestamp methods
2. ***Contact*** - A representation of a supplier or customer contact
3. ***Invoice*** - A representation of an invoice
4. ***Account*** - A representation of a bank account
5. ***Transaction*** - A representation of a bank transaction
6. ***Loan*** - A representation of a loan
"""

# === Imports ===

# Import Python modules
from calendar import month_name
from datetime import datetime, timedelta, date
from random import choice, randrange

# Import Django modules
from django.utils import timezone
from django.db import models
from django.db.models import Sum, Avg
from django.db.models import When, F, Q, ExpressionWrapper, fields
from django.db.models import IntegerField, FloatField
from django.db.models import CharField, Case, Value, When
from django.db.models.functions import ExtractMonth
from django.core.exceptions import ValidationError
from django.core.validators import MinLengthValidator
from django.core.exceptions import ValidationError
from django.utils.translation import ugettext_lazy as _

from django.urls import reverse

# Import Bankifi utility methods
from cashflow.utilities import due_date

# === Globals ===


# === Model Managers ===


# === Model Classes ===

class Base(models.Model):
    """
    **Base(models.Model)**

    Base parent model for all the models to provide a set of standard timestamp methods.

    **Public Attributes:**

    ***timestamp***: Editable timestamp.

    ***created***: Date and time model instance was created.

    ***updated***: Date and time model instance was updated.
    """
    timestamp = models.DateTimeField(blank=True, editable=False, db_index=True)
    created = models.DateTimeField(auto_now=False, auto_now_add=True, editable=False, verbose_name="Created")
    updated = models.DateTimeField(auto_now=True, auto_now_add=False, editable=False, verbose_name="Last Updated")

    
    def __init__(self, *args, **kwargs):
        super(Base, self).__init__(*args, **kwargs)

    class Meta:
        abstract = True

    # Override save method.
    def save(self,  *args, **kwargs):
        if not self.timestamp:
            self.timestamp = timezone.now()

        update_timestamp = kwargs.pop('update_timestamp', False)
        if update_timestamp:
            self.timestamp = timezone.now()

        super(Base, self).save(*args, **kwargs)




class Contact(Base):
    """
    **Contact(Base)**

    A representation of a supplier or customer contact.

    **Public Attributes:**

    ***name***: Contacts full name.

    ***first_name***: Contacts first name.

    ***last_name***: Contacts last name.

    **Methods:**

    """
    name = models.CharField(max_length=60, help_text="Full name", verbose_name="Name", blank=True)
    first_name = models.CharField(max_length=30, help_text="First name", verbose_name="First Name")
    last_name = models.CharField(max_length=30, help_text="Full name", verbose_name="Last Name")

    class meta:
        ordering = ['name']

    # Override save method to set the full name using first and last name.
    def save(self,  *args, **kwargs):
        if self.first_name and self.last_name:
            self.name = self.first_name + ' ' + self.last_name

        super(Contact, self).save(*args, **kwargs)


    def __str__(self):
        return "{0}".format(self.name)


    def get_absolute_url(self):
        return reverse("nordea:contactdetail", kwargs={"pk":self.pk})



 
class Account(Base):
    """
    **Account(Base)**

    A representation of a Bank Account.

    Utilises a subset of banks.
    A bank account can have an optional sweep bank account associated with it.
    The sweep account will be used to try and return the account to a minimum balance level if 
    there is an attempt to withdraw funds that would otherwise cause a transaction to be declined or
    cause the account to become overdrawn.

    Future Work: decouple Xero calls from class to allow multiple 3rd party providers

    **Public Attributes:**
    
    ***bank***: bank name limited by a set of choices.
    
    ***name***: account name.
    
    ***sortcode***: bank sortcode.

    ***account_number***: bank account number.

    ***sweep_min_balance***: minimum balance before sweep rule takes effect.

    ***sweep_account***: foreign key to optional sweep account.

    ***account_id***: Id of Xero equivalent account.

    **Methods:**

    ***sweep***: sweep funds from linked sweep account to restore balance to minimum level.

    ***deposit***: deposit funds.

    ***withdraw***: withdraw funds.

    ***transaction_check***: check if sufficient funds available prior to withdrawal.

    ***balance***: return the current bank account balance.
    """
    # Subset of available banks. Add to this list to add more or setup in database in future.
    BARCLAYS = 'BARCLAYS'
    HSBC = 'HSBC'
    NORDEA = 'NORDEA'
    NATIONWIDE = 'NATIONWIDE'
    RBS = 'RBS'
    LLOYDS = 'LLOYDS'
    SANTANDER = 'SANTANDER'

    BANK = (
        (BARCLAYS, 'BARCLAYS'),
        (HSBC, 'HSBC'),
        (NORDEA, 'NORDEA'),
        (NATIONWIDE, 'NATIONWIDE'),
        (RBS, 'RBS'),
        (LLOYDS, 'LLOYDS'),
        (SANTANDER, 'SANTANDER'),
    )

    bank = models.CharField(choices=BANK, max_length=10, help_text="Bank", 
        verbose_name="Bank", default=NATIONWIDE)
    name = models.CharField(max_length=40, help_text="Account Name", 
        verbose_name="Account Name", blank=True)
    sortcode = models.CharField(max_length=6, validators=[MinLengthValidator(6)], 
        help_text="Sort code", verbose_name="Sort code", blank=True)
    account_number = models.CharField(max_length=9, 
        validators=[MinLengthValidator(8)], help_text="Bank account number", 
        verbose_name="Account Number")
    sweep_min_balance = models.FloatField(default=0, 
        help_text="Balance before sweeping", verbose_name="Sweep Balance Limit")
    sweep_account = models.ForeignKey('Account', null=True, blank=True,
        help_text="Account to use to sweep from", verbose_name="Sweep Account")

    class meta:
        ordering = ['bank']

    # Override save method to setup made up bank sortcodes and conduct account sweep if necessary.
    def save(self,  *args, **kwargs):
        sort_codes = {
            'BARCLAYS': '111111',
            'HSBC': '222222',
            'NORDEA': '333333',
            'NATIONWIDE': '444444',
            'RBS': '555555',
            'LLOYDS': '666666',
            'SANTANDER': '777777',
        }
        super(Account, self).save(*args, **kwargs)

        if not self.name:
            self.name = "Bank Account {0}".format(self.id)
            # Save to set primary key id
            super(Account, self).save(*args, **kwargs)

        if not self.sortcode:
            self.sortcode = sort_codes.get(self.bank, '000000')
            super(Account, self).save(*args, **kwargs)

        if self.balance < self.sweep_min_balance:
            self.sweep()

        
    def sweep(self, amount=0.0):
        """
        **sweep(self, amount=0.0, xero=None)**

        Sweep funds from linked bank account to restore balance to minimum level.

        Sweeps only the funds required to make withdrawal amount and set account to minimum balance.
        The sweep is applied to both Bankifi and Xero.

        Future Work: decouple Xero calls from class to allow multiple 3rd party providers

        **Parameters:**

        ***amount***: amount to be withdrawn from account.

        ***xero***: xero connection object.

        **Returns:**

        Nothing
        """
        amount_required = (amount - self.balance) + self.sweep_min_balance
        if self.sweep_account:
            self.sweep_account.withdraw(amount_required, "Sweep Payment to {0} {1}".format(self.sortcode, self.account_number))
            self.deposit(amount_required, "Sweep Payment from {0} {1}".format(self.sortcode, self.account_number))
            
            

    def deposit(self, amount=0.0, description="Deposit"):
        """
        **deposit(self, amount=0.0, description="Deposit", xero=None, contact_id=None, account_id='')**

        Deposit funds into bank account. Updates Bankifi and Xero account.

        Future Work: decouple Xero calls from class to allow multiple 3rd party providers.

        **Parameters:**

        ***amount***: deposit amount.

        ***description***: deposit description.

        ***xero***: xero connection object.

        ***contact_id***: Xero contact id.

        ***account_id***: Xero account id.

        **Returns:**

        True if successful. False if unsuccessful.
        """
        # Only deposit positive amounts > 0
        if amount > 0:
            # Create bankif transaction to deposit funds
            t = Transaction(account=self, transaction_type=Transaction.CREDIT, amount=amount, 
                    description=description)
            
            # Save Bankifi Transaction
            if t is not None:
                t.save()
            return True
        else:
            return False


    def withdraw(self, amount=0.0, description="Withdrawal"):
        """
        **withdraw(self, amount=0.0, description="Withdrawal", xero=None, contact_id=None, account_id='')**

        Withdraw funds from bank account. Updates Bankifi and Xero account.

        Future Work: decouple Xero calls from class to allow multiple 3rd party providers

        **Parameters:**

        ***amount***: withdrawal amount.

        ***description***: withdrawal description.

        ***xero***: xero connection object.

        ***contact_id***: Xero contact id.

        ***account_id***: Xero account id.

        **Returns:**

        True is successful. False if unsuccessful.
        """
        # Check the withdrawal amount is > 0 and that the account has sufficient funds for withdrawal
        if amount > 0 and self.transaction_check(amount):
            # Create bankif transaction to withdraw funds
            t = Transaction(account=self, transaction_type=Transaction.DEBIT, amount=amount, 
                    description=description)
            
            # Save Bankifi Transaction
            if t is not None:
                t.save()
            return True
        else:
            return False



    def transaction_check(self, amount):
        """
        **transaction_check(self, amount, xero=None)**

        Checks account has sufficient funds prior to making withdrawal.

        Will include the funds available within a sweep account as part of the check if necessary.


        **Parameters:**

        ***amount***: withdrawal amount

        ***xero***: xero connection object

        **Returns:**

        True if successful. False if unsuccessful.
        """
        if self.balance >= amount:
            return True
        elif self.sweep_account and self.sweep_account.transaction_check(amount-self.balance):
            self.sweep(amount)
            return True
        else:
            return False 


    @property
    def balance(self):
        """
        **balance(self)**

        Returns the balance of the bank account.

        Aggregates the transactions against the account to find the current balance.

        **Returns:**

        The account balance or 0 if no transactions exist.
        """     
        if Transaction.objects.filter(account_id=self.id).exists():
            return Transaction.objects.filter(account_id=self.id).aggregate(Sum('amount')).get('amount__sum',0.0)
        else:
            return 0.0


    def __str__(self):
        return "{0} {1} {2}".format(self.bank, self.name, self.account_number)


    def get_absolute_url(self):
        return reverse("cashflow:accountdetail", kwargs={"pk":self.pk})



class Transaction(Base):
    """
    **Transaction(Base)**

    A representation of a bank transaction.

    A transaction can be a debit or a credit transaction.

    Future Work: decouple Xero calls from class to allow multiple 3rd party providers.

    **Public Attributes:**

    ***account***: foreign key to bank account.

    ***transaction_type***: type of transaction; DEBIT or CREDIT.

    ***amount***: transaction amount.

    ***contact***: foreign key to contact for transaction.

    ***transdate***: date and time of transaction.

    ***transaction_id***: Id of Xero equivalent transaction.
    """
    DEBIT = 'DEBIT'
    CREDIT = 'CREDIT'
    TRANSACTION_TYPE = (
        (DEBIT, 'Debit'),
        (CREDIT, 'Credit'),
    )

    account = models.ForeignKey('Account', help_text="Bank Account", verbose_name="Account", on_delete=models.CASCADE)
    transaction_type = models.CharField(choices=TRANSACTION_TYPE, max_length=10, help_text="Transaction type", 
        verbose_name="Type")
    amount = models.FloatField(default=0.0, help_text="Transaction Amount", verbose_name="Amount")
    description = models.CharField(max_length=250, help_text="Transaction description", verbose_name="Description", 
        blank=True)
    contact = models.ForeignKey('contact', verbose_name="Contact", null=True)
    transdate = models.DateTimeField(blank=True, verbose_name="Date and Time", help_text="Transaction date and time", 
        auto_now=True)
    transaction_id = models.CharField(max_length=100, verbose_name="Account ID", blank=True)


    class meta:
        ordering = ['-created']


    # Override save method to ensure correct amounts are applied to the account.
    def save(self,  *args, **kwargs):
        if not self.description:
            self.description = "{0} Payment".format(self.transaction_type)

        # Ensure positive amounts from credits and negative amount for debits
        if self.amount < 0.0 and self.transaction_type == self.CREDIT:
            self.amount = self.amount * -1.0

        if self.amount > 0.0 and self.transaction_type == self.DEBIT:
            self.amount = self.amount * -1.0

        super(Transaction, self).save(*args, **kwargs)
        

    def __str__(self):
        return "{0}".format(self.id)


    def get_absolute_url(self):
        return reverse("cashflow:transactiondetail", kwargs={"pk":self.pk})

